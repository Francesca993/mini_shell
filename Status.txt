
âœ… FUNZIONALITÃ€ GIÃ€ IMPLEMENTATE (almeno parzialmente)
Prompt interattivo: con readline() e add_history() â†’ presente in main.c.
Parsing della linea: lexer() e parser() con gestione di token, quote, pipe, redirezioni.
Gestione delle quote:
'...' â†’ disattiva espansioni (vedi expand_single_quotes).
"..." â†’ permette espansione di $, con gestione di \$ tramite handle_backslash.
Espansione di $VAR e $?: Ã¨ impostato lo scheletro per cmd->dollar, anche se expand_var() non Ã¨ ancora implementato.
Gestione dei backslash fuori dalle quote: tramite handle_backslash_outside_quotes().
Parsing delle redirezioni (<, >, <<, >>): gestite correttamente in populate_comands().
Pipe (|): riconosciute e separate nei comandi.
Gestione dei segnali (Ctrl+C, Ctrl+D): accennata, ma non ancora gestita esplicitamente.
Struttura t_pipeline ben definita per rappresentare comandi multipli.
Gestione memoria (free): presente free_pipeline() e free_partial_tokens().
ðŸ›  COSA MANCA O VA COMPLETATO
Esecuzione dei comandi:
Nessuna chiamata a fork(), execve() o dup2() Ã¨ presente.
Serve implementare execute_cmd() o una funzione equivalente.
Deve includere:
Ricerca nei path (PATH)
Gestione redirezioni (dup2)
Pipe tra comandi
Comandi built-in (vedi sotto)
Built-in commands:
Da implementare:
echo -n
cd [path]
pwd
export
unset
env
exit
Al momento nessun file mostra implementazioni per questi comandi.
Espansione variabili:
Funzione expand_var() Ã¨ solo commentata.
Da scrivere per espandere $VAR e $? leggendo da env.
Gestione segnali:
Ctrl+C deve stampare un nuovo prompt (SIGINT)
Ctrl+D esce dalla shell (EOF)
Ctrl+\ non deve fare nulla
Serve un handler per SIGINT, SIGQUIT, ecc.
Makefile conforme al subject:
Deve contenere le regole all, clean, fclean, re, $(NAME).
Non fornito, ma richiesto per la valutazione.
ðŸ§ª Suggerimenti su come procedere
Scrivere expand_var(): funzione per espandere $VAR usando getenv() o un array env[].
Implementare execute_pipeline():
Cicla su pipeline->cmds
Usa fork(), execve(), pipe() e dup2() per collegare i comandi.
Gestire i built-in:
Puoi fare un check: if (strcmp(cmd->args[0], "cd") == 0), ecc.
Implementarli in file separati tipo builtins.c.
Aggiungere gestione segnali (signal.h):
Usa signal(SIGINT, handler) e definisci handler() che resetta il prompt.